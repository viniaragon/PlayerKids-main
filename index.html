<!DOCTYPE html>
<html lang="pt-br" class="bg-gray-900 text-gray-200">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Feed - Curadoria de Vídeos</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .scroll-container::-webkit-scrollbar {
            width: 8px;
        }
        .scroll-container::-webkit-scrollbar-track {
            background: #111827;
        }
        .scroll-container::-webkit-scrollbar-thumb {
            background: #4B5563;
            border-radius: 4px;
        }
        .scroll-container::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Modal para mensagens e conteúdos gerados -->
    <div id="appModal" class="modal justify-center items-center">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-11/12 md:w-1/2 lg:w-1/3">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modalTitle" class="text-xl font-bold">Título do Modal</h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-200 text-2xl font-bold">&times;</button>
            </div>
            <div id="modalContent" class="text-gray-300">
                <!-- Conteúdo dinâmico será injetado aqui -->
            </div>
        </div>
    </div>

    <!-- Modal para o reprodutor de vídeo -->
    <div id="videoModal" class="modal hidden items-center justify-center bg-black">
        <!-- Botão para fechar -->
        <button onclick="closeVideoModal()" class="absolute top-4 right-4 text-white text-2xl font-bold">&times;</button>
        <!-- Container do player (100% largura/altura) -->
        <div id="videoPlayerContainer" class="w-full h-full"></div>
    </div>

    <!-- Container da Aplicação -->
    <div id="appContainer" class="w-full flex-1 flex flex-col p-4 sm:p-6 lg:p-8">

        <!-- Tela de Autenticação com Login/Criação de Conta -->
        <div id="authScreen" class="flex-1 flex flex-col items-center justify-center text-center">
            <h1 class="text-3xl font-bold text-red-600 mb-6">
                Bem-vindo ao Meu Feed!
            </h1>
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-sm">
                <div class="flex flex-col space-y-4">
                    <input type="email" id="emailInput" placeholder="E-mail"
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <input type="password" id="passwordInput" placeholder="Senha"
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <button id="loginButton" class="w-full px-4 py-2 text-sm font-semibold text-gray-900 bg-blue-500 hover:bg-blue-400 rounded-full transition-colors duration-200">
                        Entrar
                    </button>
                    <button id="signupButton" class="w-full px-4 py-2 text-sm font-semibold text-gray-900 bg-green-500 hover:bg-green-400 rounded-full transition-colors duration-200">
                        Criar Nova Conta
                    </button>
                </div>
            </div>
        </div>

        <!-- Conteúdo Principal da Aplicação (oculto por padrão) -->
        <div id="mainApp" class="hidden flex-1 flex-col">
            <!-- Header and Search Bar -->
            <header class="flex flex-col sm:flex-row justify-between items-center mb-6 sticky top-0 z-10 bg-gray-900 py-4">
                <div class="flex items-center space-x-2 mb-4 sm:mb-0">
                    <!-- Simple logo that looks like YouTube -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8 text-red-600">
                        <path fill-rule="evenodd" d="M19.812 5.44c.945.05.945.877 1.056 2.51l.24 3.738c.07.97.07 1.627 0 2.597l-.24 3.738c-.111 1.633-.111 2.46-.945 2.51-.925.048-3.085.088-5.112.115-.55.008-1.127.01-1.704.01-1.157 0-2.313 0-3.47 0-1.898-.024-4.04-.064-4.966-.112-.945-.05-.945-.877-1.056-2.51l-.24-3.738c-.07-.97-.07-1.627 0-2.597l.24-3.738c.111-1.633.111-2.46.945-2.51.925-.048 3.085-.088 5.112-.115.55-.008 1.127-.01 1.704-.01 1.157 0 2.313 0 3.47 0 2.03.028 4.172.067 5.112.115ZM12 8.711v6.588l5.44-3.295-5.44-3.293Z" clip-rule="evenodd" />
                    </svg>
                    <h1 class="text-xl font-bold">Meu Feed</h1>
                    <!-- User menu button -->
                    <div class="relative">
                        <button id="userMenuButton" class="ml-3 w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-700 flex items-center justify-center transition-colors duration-200">
                            <!-- User icon -->
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-200">
                                <path fill-rule="evenodd" d="M12 2.25a5.25 5.25 0 0 0-2.257 10.01A9.004 9.004 0 0 0 3 20.25a.75.75 0 0 0 1.5 0 7.5 7.5 0 1 1 15 0 .75.75 0 0 0 1.5 0 9.004 9.004 0 0 0-6.743-7.99A5.251 5.251 0 0 0 12 2.25Zm0 1.5a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <!-- Dropdown menu -->
                        <div id="userMenu" class="hidden absolute right-0 mt-2 w-48 bg-gray-800 border border-gray-700 rounded-lg shadow-lg overflow-hidden z-20">
                            <button id="openSettings" class="w-full text-left px-4 py-2 text-gray-200 hover:bg-gray-700 transition-colors">Configurações</button>
                            <button id="logoutMenuItem" class="w-full text-left px-4 py-2 text-red-400 hover:bg-gray-700 transition-colors">Sair</button>
                        </div>
                    </div>
                </div>
                <div class="relative w-full sm:w-1/2">
                    <input type="text" id="searchInput" placeholder="Pesquisar vídeos..."
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <button id="searchButton" class="absolute right-0 top-0 mt-1 mr-2 px-4 py-1.5 text-sm font-semibold text-gray-900 bg-gray-400 hover:bg-gray-300 rounded-full transition-colors duration-200">
                        Buscar
                    </button>
                </div>
            </header>

            <!-- Search Results Section -->
            <section id="searchResultsContainer" class="hidden flex-col mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-center">Resultados da Busca</h2>
                <div id="searchResultsGrid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    <!-- Search results will be injected here by JavaScript -->
                </div>
                <hr class="mt-8 border-gray-700">
            </section>

            <!-- Main Video Feed Section -->
            <section class="flex-1 overflow-y-auto scroll-container">
                <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold mb-2 sm:mb-0">Seu Feed Personalizado</h2>
                    <!-- Botão de sugestões de vídeos com ✨ Gemini API -->
                    <button id="suggestTopicsButton" class="px-4 py-2 text-sm font-semibold rounded-full bg-yellow-600 hover:bg-yellow-500 transition-colors duration-200">
                        ✨ Sugerir Tópicos
                    </button>
                </div>
                <div id="userInfo" class="text-sm text-gray-300 mb-4 flex flex-col sm:flex-row items-center justify-center gap-2">
                    <div>
                        Autenticado como: <span id="userEmailDisplay" class="font-medium"></span>
                    </div>
                    <button id="logoutButton" class="px-3 py-1 text-xs font-semibold rounded-full bg-gray-700 hover:bg-gray-600 text-gray-100 transition-colors duration-200">
                        Sair
                    </button>
                </div>
                <!-- Filtros e Busca do Feed -->
                <div id="feedFilters" class="mb-4 flex flex-col sm:flex-row items-stretch sm:items-center justify-between gap-3">
                    <input id="feedSearchInput" type="text" placeholder="Buscar no feed (título, descrição, tema)" class="w-full sm:w-1/2 px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200" />
                    <div class="flex gap-2 w-full sm:w-auto">
                        <select id="channelFilter" class="flex-1 sm:flex-none px-3 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                            <option value="all">Todos os canais</option>
                        </select>
                        <select id="watchedFilter" class="flex-1 sm:flex-none px-3 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                            <option value="all">Todos</option>
                            <option value="new">Novos</option>
                            <option value="watched">Assistidos</option>
                        </select>
                    </div>
                </div>
                <div class="flex justify-end mb-4">
                    <button id="bgPlayButton" class="px-4 py-2 text-sm font-semibold rounded-full bg-indigo-600 hover:bg-indigo-500 text-white transition-colors duration-200">
                        Segundo plano
                    </button>
                </div>
                <div id="curatedFeedContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    <!-- User's curated videos will be injected here by JavaScript -->
                </div>
            </section>
        </div>
    </div>

    <!-- JavaScript for functionality -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue, set } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // Variáveis para armazenar o estado global
        let curatedFeed = [];
        let currentSearchResults = [];
        let userId = null;
        let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let player;
        let isDragging = false;
        
        // A sua chave da API do YouTube
        const YOUTUBE_API_KEY = "AIzaSyAmNMrkBFKqaUV-aOa1XBtJ5sEKBjDJwWA";

        // Esta função é chamada automaticamente quando a API do YouTube está pronta
        window.onYouTubeIframeAPIReady = () => {
            // A API está pronta, mas o player só será criado quando o usuário clicar em um vídeo.
        };

        // Função para lidar com o fim de um vídeo
        function onPlayerStateChange(event) {
            // Verifica se o vídeo terminou
            if (event.data === YT.PlayerState.ENDED) {
                const currentVideoId = event.target.getVideoData().video_id;
                const currentIndex = curatedFeed.findIndex(v => v.id === currentVideoId);
                const nextIndex = currentIndex + 1;

                // Se houver um próximo vídeo no feed, reproduza-o
                if (nextIndex < curatedFeed.length) {
                    const nextVideoId = curatedFeed[nextIndex].id;
                    playVideo(nextVideoId);
                } else {
                    // Se for o último vídeo, feche o modal
                    closeVideoModal();
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            // --- DOM Elements ---
            const authScreen = document.getElementById('authScreen');
            const mainApp = document.getElementById('mainApp');
            const emailInput = document.getElementById('emailInput');
            const passwordInput = document.getElementById('passwordInput');
            const loginButton = document.getElementById('loginButton');
            const signupButton = document.getElementById('signupButton');
            const userEmailDisplay = document.getElementById('userEmailDisplay');

            const searchInput = document.getElementById('searchInput');
            const searchButton = document.getElementById('searchButton');
            const searchResultsContainer = document.getElementById('searchResultsContainer');
            const searchResultsGrid = document.getElementById('searchResultsGrid');
            const curatedFeedContainer = document.getElementById('curatedFeedContainer');
            const appModal = document.getElementById('appModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            const suggestTopicsButton = document.getElementById('suggestTopicsButton');
            const videoModal = document.getElementById('videoModal');
            const videoPlayerContainer = document.getElementById('videoPlayerContainer');
            const logoutButton = document.getElementById('logoutButton');
            const feedSearchInput = document.getElementById('feedSearchInput');
            const channelFilter = document.getElementById('channelFilter');
            const watchedFilter = document.getElementById('watchedFilter');
            const userMenuButton = document.getElementById('userMenuButton');
            const userMenu = document.getElementById('userMenu');
            const logoutMenuItem = document.getElementById('logoutMenuItem');
            const openSettings = document.getElementById('openSettings');
            const bgPlayButton = document.getElementById('bgPlayButton');

            // --- Firebase Setup ---
            const firebaseConfig = {
                apiKey: "AIzaSyAMiRmCeV0_S4-rl_Gh1K6SRo2Z1k1jQI0",
                authDomain: "nexomedicina-vr.firebaseapp.com",
                databaseURL: "https://nexomedicina-vr-default-rtdb.firebaseio.com",
                projectId: "nexomedicina-vr",
                storageBucket: "nexomedicina-vr.firebasestorage.app",
                messagingSenderId: "680752127319",
                appId: "1:680752127319:web:19e2a2027ea04d2e3d3212",
                measurementId: "G-EJLDRX2TKK"
            };

            const app = initializeApp(firebaseConfig);
            const db = getDatabase(app);
            const auth = getAuth(app);

            // --- Authentication Logic ---
            loginButton.addEventListener('click', async () => {
                const email = emailInput.value;
                const password = passwordInput.value;
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    showModal("Erro de Login", `Falha ao entrar: ${error.message}`);
                }
            });

            signupButton.addEventListener('click', async () => {
                const email = emailInput.value;
                const password = passwordInput.value;
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showModal("Sucesso", "Conta criada com sucesso! Você já está logado.");
                } catch (error) {
                    showModal("Erro ao Criar Conta", `Falha ao criar conta: ${error.message}`);
                }
            });

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userEmailDisplay.textContent = user.email;
                    // Esconde a tela de autenticação e mostra o app principal
                    authScreen.classList.add('hidden');
                    mainApp.classList.remove('hidden');
                    listenToCuratedFeed();
                } else {
                    // Se o usuário não estiver logado, mostra a tela de autenticação
                    mainApp.classList.add('hidden');
                    authScreen.classList.remove('hidden');
                }
            });
            
            // Logout
            if (logoutButton) {
                logoutButton.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                    } catch (error) {
                        showModal("Erro ao Sair", `Falha ao sair da conta: ${error.message}`);
                    }
                });
            }

            // User menu (toggle + outside click)
            if (userMenuButton && userMenu) {
                userMenuButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    userMenu.classList.toggle('hidden');
                });
                document.addEventListener('click', (e) => {
                    if (!userMenu.classList.contains('hidden')) {
                        const within = userMenu.contains(e.target) || userMenuButton.contains(e.target);
                        if (!within) userMenu.classList.add('hidden');
                    }
                });
            }

            // User menu items
            if (logoutMenuItem) {
                logoutMenuItem.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                    } catch (error) {
                        showModal("Erro ao Sair", `Falha ao sair da conta: ${error.message}`);
                    } finally {
                        if (userMenu) userMenu.classList.add('hidden');
                    }
                });
            }
            if (openSettings) {
                openSettings.addEventListener('click', () => {
                    showModal('Configurações', '<p class="text-gray-300">Em breve: preferências e ajustes da conta.</p>');
                    if (userMenu) userMenu.classList.add('hidden');
                });
            }

            // --- Background playback helpers ---
            function setupMediaSession(video) {
                if (!('mediaSession' in navigator) || !video) return;
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: video.title || 'Reprodução',
                        artist: video.channel || 'Canal',
                        album: 'Meu Feed',
                        artwork: video.thumbnail ? [
                            { src: video.thumbnail, sizes: '512x288', type: 'image/jpeg' }
                        ] : []
                    });

                    navigator.mediaSession.setActionHandler('play', () => player?.playVideo?.());
                    navigator.mediaSession.setActionHandler('pause', () => player?.pauseVideo?.());
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        const currentId = player?.getVideoData?.().video_id;
                        const i = curatedFeed.findIndex(v => v.id === currentId);
                        if (i > 0) playVideo(curatedFeed[i - 1].id);
                    });
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        const currentId = player?.getVideoData?.().video_id;
                        const i = curatedFeed.findIndex(v => v.id === currentId);
                        if (i !== -1 && i + 1 < curatedFeed.length) playVideo(curatedFeed[i + 1].id);
                    });
                } catch (_) {}
            }

            async function enterBackgroundPlayback() {
                if (!player) {
                    showModal('Segundo plano', 'Abra um vídeo do seu feed primeiro.');
                    return;
                }
                try {
                    const iframe = player.getIframe();
                    if (iframe) {
                        const allow = iframe.getAttribute('allow') || '';
                        const merged = Array.from(new Set((allow + '; autoplay; encrypted-media; picture-in-picture; fullscreen').split(';').map(s => s.trim()).filter(Boolean))).join('; ');
                        iframe.setAttribute('allow', merged);
                        iframe.setAttribute('allowfullscreen', 'true');
                        iframe.setAttribute('playsinline', '1');
                    }
                    // Tentativa programática de PiP (pode não estar disponível)
                    if (document.pictureInPictureEnabled && iframe && typeof iframe.requestPictureInPicture === 'function') {
                        await iframe.requestPictureInPicture();
                        return;
                    }
                } catch (_) { /* silent */ }

                // Instruções de fallback
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                let tips = '';
                if (isIOS) {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Toque no vídeo em tela cheia e depois no botão Picture‑in‑Picture.</li><li>Saia do Safari: o áudio continua no fundo.</li></ul>';
                } else if (isAndroid) {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Toque no ícone Picture‑in‑Picture no player (ou use o menu do vídeo).</li><li>Pressione Home: o PiP mantém o áudio.</li></ul>';
                } else {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Clique com o botão direito no vídeo (duas vezes, se necessário) e escolha “Picture in Picture”.</li><li>Ou use o botão PiP na barra do player.</li></ul>';
                }
                showModal('Reprodução em segundo plano', `<p class="mb-2">Para continuar ouvindo com a tela minimizada, use Picture‑in‑Picture:</p>${tips}`);
            }

            if (bgPlayButton) {
                bgPlayButton.addEventListener('click', () => enterBackgroundPlayback());
            }

            // --- Realtime Database Functions ---
            const curatedFeedRef = () => ref(db, `/artifacts/${appId}/users/${userId}/curated_feed/feed_doc`);

            const listenToCuratedFeed = () => {
                if (!userId) {
                    console.error("Usuário não autenticado. Não é possível ouvir o feed.");
                    return;
                }
                onValue(curatedFeedRef(), (snapshot) => {
                    const data = snapshot.val();
                    curatedFeed = data?.videos ?? [];
                    renderCuratedFeed();
                }, (error) => {
                    console.error("Erro ao ouvir o feed:", error);
                    showModal("Erro de Banco de Dados", "Não foi possível carregar o seu feed. Por favor, tente novamente.");
                });
            };

            const saveCuratedFeed = async () => {
                if (!userId) {
                    console.error("Não é possível salvar o feed: usuário não autenticado.");
                    return;
                }
                try {
                    await set(curatedFeedRef(), { videos: curatedFeed });
                } catch (e) {
                    console.error("Erro ao salvar o feed:", e);
                    showModal("Erro ao Salvar", "Não foi possível salvar seu feed. Tente novamente.");
                }
            };

            // --- Utility Functions ---
            function showModal(title, content) {
                modalTitle.textContent = title;
                modalContent.innerHTML = content;
                appModal.style.display = 'flex';
            }

            window.closeModal = () => {
                appModal.style.display = 'none';
            };

            window.closeVideoModal = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                if (player) {
                    player.destroy();
                    player = null;
                }
                videoPlayerContainer.innerHTML = '';
                videoModal.classList.remove('flex');
                videoModal.classList.add('hidden');
            };

            function createVideoCard(video, isSearchResult = true) {
                const card = document.createElement('div');
                card.className = 'bg-gray-800 rounded-lg shadow-lg overflow-hidden transition-transform duration-200 hover:scale-105 hover:z-10 cursor-pointer';

                let buttonHtml = '';
                if (isSearchResult) {
                    buttonHtml = `
                        <button onclick="event.stopPropagation(); addToFeed('${video.id}')"
                                class="w-full mt-2 px-4 py-2 text-sm font-semibold text-gray-900 bg-blue-500 hover:bg-blue-400 rounded-full transition-colors duration-200">
                            Adicionar ao Feed
                        </button>
                        <button onclick="event.stopPropagation(); summarizeVideo('${video.id}')"
                                class="w-full mt-2 px-4 py-2 text-sm font-semibold rounded-full bg-purple-600 hover:bg-purple-500 transition-colors duration-200">
                            ✨ Resumir Vídeo
                        </button>
                    `;
                } else {
                    buttonHtml = '';
                }

                card.innerHTML = `
                    <div class="relative w-full aspect-video">
                        <img src="${video.thumbnail}" alt="Thumbnail do vídeo" class="w-full h-full object-cover">
                    </div>
                    <div class="p-4">
                        <h3 class="text-lg font-semibold line-clamp-2">${video.title}</h3>
                        <p class="text-sm text-gray-400 mt-1">${video.channel}</p>
                        <p class="text-xs text-gray-500">${video.views}</p>
                        ${buttonHtml}
                    </div>
                `;

                if (!isSearchResult) {
                    // Arrastar para reordenar
                    card.setAttribute('draggable', 'true');
                    card.dataset.videoId = video.id;
                    card.addEventListener('dragstart', (e) => {
                        isDragging = true;
                        e.dataTransfer.setData('text/plain', video.id);
                        e.dataTransfer.effectAllowed = 'move';
                        card.classList.add('opacity-50');
                    });
                    card.addEventListener('dragend', () => {
                        isDragging = false;
                        card.classList.remove('opacity-50');
                    });
                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        card.classList.add('ring-2', 'ring-blue-500');
                    });
                    card.addEventListener('dragleave', () => {
                        card.classList.remove('ring-2', 'ring-blue-500');
                    });
                    card.addEventListener('drop', (e) => {
                        e.preventDefault();
                        card.classList.remove('ring-2', 'ring-blue-500');
                        const draggedId = e.dataTransfer.getData('text/plain');
                        if (!draggedId || draggedId === video.id) return;
                        const fromIndex = curatedFeed.findIndex(v => v.id === draggedId);
                        const toIndex = curatedFeed.findIndex(v => v.id === video.id);
                        if (fromIndex === -1 || toIndex === -1) return;
                        const [moved] = curatedFeed.splice(fromIndex, 1);
                        curatedFeed.splice(toIndex, 0, moved);
                        saveCuratedFeed();
                        renderCuratedFeed();
                    });

                    // Clique para reproduzir (ignora se estiver arrastando)
                    card.addEventListener('click', () => {
                        if (isDragging) return;
                        playVideo(video.id);
                    });
                }
                
                return card;
            }

            function renderCuratedFeed() {
                curatedFeedContainer.innerHTML = '';
                rebuildChannelOptions();
                // Filtros
                const q = (feedSearchInput?.value || '').toLowerCase().trim();
                const selectedChannel = channelFilter?.value || 'all';
                const watchedMode = watchedFilter?.value || 'all';
                const filtered = curatedFeed.filter(v => {
                    const matchesQuery = !q || [v.title, v.description, v.channel].some(t => (t || '').toLowerCase().includes(q));
                    const matchesChannel = selectedChannel === 'all' || v.channel === selectedChannel;
                    const watched = !!v.watched;
                    const matchesWatched = watchedMode === 'all' || (watchedMode === 'new' ? !watched : watched);
                    return matchesQuery && matchesChannel && matchesWatched;
                });
                if (curatedFeed.length === 0) {
                    curatedFeedContainer.innerHTML = `
                        <p class="text-center text-gray-500 col-span-full mt-10">
                            Seu feed está vazio. Use a barra de pesquisa acima para encontrar vídeos e adicioná-los.
                        </p>
                    `;
                    suggestTopicsButton.classList.add('hidden');
                } else {
                    suggestTopicsButton.classList.remove('hidden');
                    if (filtered.length === 0) {
                        curatedFeedContainer.innerHTML = `
                            <p class="text-center text-gray-500 col-span-full mt-10">
                                Nenhum v��deo corresponde aos filtros/busca do feed.
                            </p>
                        `;
                    } else {
                        filtered.forEach(video => {
                            const card = createVideoCard(video, false);
                            curatedFeedContainer.appendChild(card);
                        });
                    }
                }
            }

            function rebuildChannelOptions() {
                if (!channelFilter) return;
                const current = channelFilter.value;
                const unique = Array.from(new Set(curatedFeed.map(v => v.channel).filter(Boolean))).sort((a, b) => a.localeCompare(b));
                channelFilter.innerHTML = '<option value="all">Todos os canais</option>' + unique.map(c => `<option value="${c.replace(/"/g, '&quot;')}">${c}</option>`).join('');
                if (unique.includes(current)) {
                    channelFilter.value = current;
                } else {
                    channelFilter.value = 'all';
                }
            }

            // --- Main Application Logic ---
            window.searchVideos = async () => {
                const query = searchInput.value.trim();
                if (!query) return;

                searchResultsGrid.innerHTML = `
                    <p class="col-span-full text-center text-gray-400">Buscando vídeos no YouTube...</p>
                    <div class="col-span-full flex justify-center mt-4">
                        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
                    </div>
                `;
                searchResultsContainer.classList.remove('hidden');

                try {
                    const response = await fetch(`https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(query)}&type=video&key=${YOUTUBE_API_KEY}`);
                    const data = await response.json();
                    
                    if (data.items && data.items.length > 0) {
                        searchResultsGrid.innerHTML = '';
                        const videos = data.items.map(item => ({
                            id: item.id.videoId,
                            title: item.snippet.title,
                            channel: item.snippet.channelTitle,
                            thumbnail: item.snippet.thumbnails.high.url,
                            views: 'N/A',
                            description: item.snippet.description
                        }));
                        currentSearchResults = videos;

                        videos.forEach(video => {
                            const card = createVideoCard(video, true);
                            searchResultsGrid.appendChild(card);
                        });
                    } else {
                        searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-gray-500">Nenhum vídeo encontrado para "${query}".</p>`;
                        currentSearchResults = [];
                    }
                } catch (error) {
                    console.error("Erro ao buscar vídeos do YouTube:", error);
                    searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Ocorreu um erro ao conectar com a API do YouTube. Verifique sua chave de API ou sua conexão com a internet.</p>`;
                    currentSearchResults = [];
                }
            };

            window.addToFeed = (videoId) => {
                const videoToAdd = currentSearchResults.find(video => video.id === videoId);
                if (videoToAdd) {
                    const isDuplicate = curatedFeed.some(video => video.id === videoToAdd.id);
                    if (!isDuplicate) {
                        curatedFeed.unshift(videoToAdd);
                        saveCuratedFeed();
                    } else {
                        showModal("Aviso", "Este vídeo já está no seu feed!");
                    }
                } else {
                    showModal("Erro", "Vídeo não encontrado nos resultados da busca.");
                }
            };

            window.removeFromFeed = (videoId) => {
                const index = curatedFeed.findIndex(video => video.id === videoId);
                if (index !== -1) {
                    curatedFeed.splice(index, 1);
                    saveCuratedFeed();
                }
            };

            window.playVideo = (videoId) => {
                // Marca como assistido ao abrir o vídeo
                const idx = curatedFeed.findIndex(v => v.id === videoId);
                if (idx !== -1 && !curatedFeed[idx].watched) {
                    curatedFeed[idx].watched = true;
                    saveCuratedFeed();
                    renderCuratedFeed();
                }
                // Atualiza Media Session
                try {
                    const meta = curatedFeed.find(v => v.id === videoId) || currentSearchResults.find(v => v.id === videoId);
                    setupMediaSession(meta);
                } catch (_) {}
                videoModal.classList.remove('hidden');
                videoModal.classList.add('flex');
                if (!player) {
                    // Cria o player do YouTube pela primeira vez
                    player = new YT.Player('videoPlayerContainer', {
                        height: '100%',
                        width: '100%',
                        videoId: videoId,
                        events: {
                            'onStateChange': onPlayerStateChange,
                            'onReady': e => {
                                const ifr = e.target.getIframe();
                                try {
                                    const allow = ifr.getAttribute('allow') || '';
                                    const merged = Array.from(new Set((allow + '; autoplay; encrypted-media; picture-in-picture; fullscreen').split(';').map(s => s.trim()).filter(Boolean))).join('; ');
                                    ifr.setAttribute('allow', merged);
                                    ifr.setAttribute('allowfullscreen', 'true');
                                    ifr.setAttribute('playsinline', '1');
                                } catch (_) {}
                                e.target.getIframe().requestFullscreen();
                            }
                        }
                    });
                } else {
                    // Se o player já existe, apenas carrega o novo vídeo
                    player.loadVideoById(videoId);
                    const iframe = player.getIframe();
                    if (iframe.requestFullscreen) iframe.requestFullscreen();
                }
            };
            
            // --- Gemini API Integrations ---
            window.summarizeVideo = async (videoId) => {
                const video = currentSearchResults.find(v => v.id === videoId);
                if (!video) {
                    showModal("Erro", "Vídeo não encontrado nos resultados da busca.");
                    return;
                }

                showModal("Resumindo Vídeo...", '<div class="text-center"><p>Gerando resumo com a inteligência do Gemini...</p><div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mt-4"><div class="bg-blue-500 h-full w-full animate-pulse"></div></div></div>');

                try {
                    const prompt = `Gere um resumo curto e objetivo (no máximo 3 frases) para o seguinte vídeo. Considere o título, o canal e a descrição:
                    Título: ${video.title}
                    Canal: ${video.channel}
                    Descrição: ${video.description || 'Nenhuma descrição fornecida.'}`;

                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "" 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error('Falha na resposta da API.');

                    const result = await response.json();
                    const summary = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (summary) {
                        showModal("Resumo do Vídeo", summary);
                    } else {
                        showModal("Erro", "Não foi possível gerar o resumo. Tente novamente mais tarde.");
                    }
                } catch (error) {
                    console.error("Erro ao gerar resumo:", error);
                    showModal("Erro", "Ocorreu um erro ao conectar com o serviço de IA. Por favor, tente novamente.");
                }
            };

            suggestTopicsButton.addEventListener('click', async () => {
                if (curatedFeed.length === 0) {
                    showModal("Aviso", "Adicione vídeos ao seu feed primeiro para receber sugestões de tópicos.");
                    return;
                }

                showModal("Gerando Sugestões...", '<div class="text-center"><p>Analisando seu feed e buscando sugestões...</p><div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mt-4"><div class="bg-yellow-500 h-full w-full animate-pulse"></div></div></div>');

                try {
                    const videoTitles = curatedFeed.map(v => v.title).join(', ');
                    const prompt = `Analise os seguintes títulos de vídeos de uma playlist e sugira 3 tópicos de vídeos relacionados para um feed. A resposta deve ser uma lista JSON de strings, sem formatação extra, como um array de strings.
                    Títulos da playlist: ${videoTitles}`;

                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: { "type": "STRING" }
                            }
                        }
                    };
                    const apiKey = ""
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error('Falha na resposta da API.');

                    const result = await response.json();
                    const suggestions = JSON.parse(result?.candidates?.[0]?.content?.parts?.[0]?.text || '[]');

                    if (suggestions.length > 0) {
                        const listHtml = `
                            <p>Com base nos vídeos do seu feed, aqui estão algumas sugestões:</p>
                            <ul class="list-disc list-inside mt-4 space-y-2">
                                ${suggestions.map(s => `<li>${s}</li>`).join('')}
                            </ul>
                        `;
                        showModal("Tópicos Sugeridos", listHtml);
                    } else {
                        showModal("Erro", "Não foi possível gerar sugestões. Tente adicionar mais vídeos ao seu feed.");
                    }
                } catch (error) {
                    console.error("Erro ao gerar sugestões:", error);
                    showModal("Erro", "Ocorreu um erro ao gerar as sugestões. Por favor, tente novamente.");
                }
            });
            
            searchButton.addEventListener('click', searchVideos);
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    searchVideos();
                }
            });
            // Eventos de filtros/busca do feed
            if (feedSearchInput) feedSearchInput.addEventListener('input', renderCuratedFeed);
            if (channelFilter) channelFilter.addEventListener('change', renderCuratedFeed);
            if (watchedFilter) watchedFilter.addEventListener('change', renderCuratedFeed);
        });
    </script>
</body>
</html>
