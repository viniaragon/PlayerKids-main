<!DOCTYPE html>
<html lang="pt-br" class="bg-gray-900 text-gray-200">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Feed - Curadoria de Vídeos</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Inter -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- YouTube IFrame Player API -->
    <script src="https://www.youtube.com/iframe_api"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        .scroll-container::-webkit-scrollbar {
            width: 8px;
        }
        .scroll-container::-webkit-scrollbar-track {
            background: #111827;
        }
        .scroll-container::-webkit-scrollbar-thumb {
            background: #4B5563;
            border-radius: 4px;
        }
        .scroll-container::-webkit-scrollbar-thumb:hover {
            background: #6B7280;
        }
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="flex flex-col min-h-screen">

    <!-- Modal para mensagens e conteúdos gerados -->
    <div id="appModal" class="modal justify-center items-center">
        <div class="bg-gray-800 p-6 rounded-lg shadow-xl w-11/12 md:w-1/2 lg:w-1/3">
            <div class="flex justify-between items-center mb-4">
                <h3 id="modalTitle" class="text-xl font-bold">Título do Modal</h3>
                <button onclick="closeModal()" class="text-gray-400 hover:text-gray-200 text-2xl font-bold">&times;</button>
            </div>
            <div id="modalContent" class="text-gray-300">
                <!-- Conteúdo dinâmico será injetado aqui -->
            </div>
        </div>
    </div>

    <!-- Modal para o reprodutor de vídeo (não usado no modo 'embutido') -->
    <div id="videoModal" class="modal hidden items-start justify-center pt-8 sm:pt-12">
        <!-- Botão para fechar -->
        <button onclick="closeVideoModal()" class="absolute top-4 right-4 text-white text-2xl font-bold">&times;</button>
        <!-- Antigo botão de segundo plano do overlay (id alterado para evitar duplicidade) -->
        <button id="bgPlayButtonModal" class="absolute bottom-4 left-4 px-4 py-2 text-sm font-semibold rounded-full bg-indigo-600 hover:bg-indigo-500 text-white transition-colors duration-200">
            Segundo plano
        </button>
        <!-- Container antigo do player (não utilizado no modo embutido) -->
        <div id="videoPlayerContainerModal" class="w-[90vw] sm:w-[70vw] md:w-[60vw] lg:w-[50vw] xl:w-[40vw] max-w-[360px] aspect-video bg-black rounded-xl overflow-hidden shadow-2xl flex items-center justify-center"></div>
    </div>

    <!-- Container da Aplicação -->
    <div id="appContainer" class="w-full flex-1 flex flex-col p-4 sm:p-6 lg:p-8">

        <!-- Tela de Autenticação com Login/Criação de Conta -->
        <div id="authScreen" class="flex-1 flex flex-col items-center justify-center text-center">
            <h1 class="text-3xl font-bold text-red-600 mb-6">
                Bem-vindo ao Meu Feed!
            </h1>
            <div class="bg-gray-800 p-8 rounded-lg shadow-lg w-full max-w-sm">
                <div class="flex flex-col space-y-4">
                    <input type="email" id="emailInput" placeholder="E-mail"
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <input type="password" id="passwordInput" placeholder="Senha"
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <button id="loginButton" class="w-full px-4 py-2 text-sm font-semibold text-gray-900 bg-blue-500 hover:bg-blue-400 rounded-full transition-colors duration-200">
                        Entrar
                    </button>
                    <button id="signupButton" class="w-full px-4 py-2 text-sm font-semibold text-gray-900 bg-green-500 hover:bg-green-400 rounded-full transition-colors duration-200">
                        Criar Nova Conta
                    </button>
                </div>
            </div>
        </div>

        <!-- Conteúdo Principal da Aplicação (oculto por padrão) -->
        <div id="mainApp" class="hidden flex-1 flex-col">
            <!-- Header and Search Bar -->
            <header class="flex flex-col sm:flex-row justify-between items-center mb-6 sticky top-0 z-10 bg-gray-900 py-4">
                <div class="flex items-center space-x-2 mb-4 sm:mb-0">
                    <!-- Simple logo that looks like YouTube -->
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-8 h-8 text-red-600">
                        <path fill-rule="evenodd" d="M19.812 5.44c.945.05.945.877 1.056 2.51l.24 3.738c.07.97.07 1.627 0 2.597l-.24 3.738c-.111 1.633-.111 2.46-.945 2.51-.925.048-3.085.088-5.112.115-.55.008-1.127.01-1.704.01-1.157 0-2.313 0-3.47 0-1.898-.024-4.04-.064-4.966-.112-.945-.05-.945-.877-1.056-2.51l-.24-3.738c-.07-.97-.07-1.627 0-2.597l.24-3.738c.111-1.633.111-2.46.945-2.51.925-.048 3.085-.088 5.112-.115.55-.008 1.127-.01 1.704-.01 1.157 0 2.313 0 3.47 0 2.03.028 4.172.067 5.112.115ZM12 8.711v6.588l5.44-3.295-5.44-3.293Z" clip-rule="evenodd" />
                    </svg>
                    <h1 class="text-xl font-bold">Meu Feed</h1>
                    <!-- User menu button -->
                    <div class="relative">
                        <button id="userMenuButton" class="ml-3 w-9 h-9 rounded-full bg-gray-800 hover:bg-gray-700 border border-gray-700 flex items-center justify-center transition-colors duration-200">
                            <!-- User icon -->
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" class="w-5 h-5 text-gray-200">
                                <path fill-rule="evenodd" d="M12 2.25a5.25 5.25 0 0 0-2.257 10.01A9.004 9.004 0 0 0 3 20.25a.75.75 0 0 0 1.5 0 7.5 7.5 0 1 1 15 0 .75.75 0 0 0 1.5 0 9.004 9.004 0 0 0-6.743-7.99A5.251 5.251 0 0 0 12 2.25Zm0 1.5a3.75 3.75 0 1 1 0 7.5 3.75 3.75 0 0 1 0-7.5Z" clip-rule="evenodd" />
                            </svg>
                        </button>
                        <!-- Dropdown menu -->
                        <div id="userMenu" class="hidden absolute right-0 mt-2 w-48 bg-gray-800 border border-gray-700 rounded-lg shadow-lg overflow-hidden z-20">
                            <button id="goToFeedMenuItem" class="w-full text-left px-4 py-2 text-gray-200 hover:bg-gray-700 transition-colors">Ir para o Feed</button>
                            <button id="openSettings" class="w-full text-left px-4 py-2 text-gray-200 hover:bg-gray-700 transition-colors">Configurações</button>
                            <button id="logoutMenuItem" class="w-full text-left px-4 py-2 text-red-400 hover:bg-gray-700 transition-colors">Sair</button>
                        </div>
                    </div>
                </div>
                <div class="relative w-full sm:w-1/2">
                    <input type="text" id="searchInput" placeholder="Pesquisar vídeos..."
                           class="w-full px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                    <button id="searchButton" class="absolute right-0 top-0 mt-1 mr-2 px-4 py-1.5 text-sm font-semibold text-gray-900 bg-gray-400 hover:bg-gray-300 rounded-full transition-colors duration-200">
                        Buscar
                    </button>
                </div>
            </header>

            <!-- Search Results Section -->
            <section id="searchResultsContainer" class="hidden flex-col mb-8">
                <h2 class="text-2xl font-semibold mb-4 text-center">Resultados da Busca</h2>
                <div id="searchFilters" class="flex flex-wrap items-center justify-center gap-3 mb-4">
                    <select id="orderSelect" class="px-3 py-2 bg-gray-800 text-gray-200 border border-gray-700 rounded-full text-sm">
                        <option value="relevance">Relevância</option>
                        <option value="date">Data de envio</option>
                        <option value="viewCount">Mais visualizados</option>
                    </select>
                    <select id="uploadDateSelect" class="px-3 py-2 bg-gray-800 text-gray-200 border border-gray-700 rounded-full text-sm">
                        <option value="any">Qualquer data</option>
                        <option value="hour">Última hora</option>
                        <option value="day">Hoje</option>
                        <option value="week">Esta semana</option>
                        <option value="month">Este mês</option>
                        <option value="year">Este ano</option>
                    </select>
                    <select id="durationSelect" class="px-3 py-2 bg-gray-800 text-gray-200 border border-gray-700 rounded-full text-sm">
                        <option value="any">Qualquer duração</option>
                        <option value="short">Curtos (até 4 min)</option>
                        <option value="medium">Médios (4–20 min)</option>
                        <option value="long">Longos (20+ min)</option>
                    </select>
                </div>
                <div class="flex justify-end mb-3">
                    <button id="exitSearchButton" class="px-3 py-1.5 text-sm font-semibold rounded-full bg-gray-700 hover:bg-gray-600 text-gray-100 transition-colors">Sair da busca</button>
                </div>
                <div id="searchResultsGrid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    <!-- Search results will be injected here by JavaScript -->
                </div>
                <hr class="mt-8 border-gray-700">
            </section>

            <!-- Main Video Feed Section -->
            <section id="feedSection" class="flex-1 overflow-y-auto scroll-container">
                <div class="flex flex-col sm:flex-row justify-between items-center mb-4">
                    <h2 class="text-2xl font-semibold mb-2 sm:mb-0">Seu Feed Personalizado</h2>
                    <!-- Botão de sugestões de vídeos com ✨ Gemini API -->
                    <button id="suggestTopicsButton" class="px-4 py-2 text-sm font-semibold rounded-full bg-yellow-600 hover:bg-yellow-500 transition-colors duration-200">
                        ✨ Sugerir Tópicos
                    </button>
                </div>
                <div id="userInfo" class="text-sm text-gray-300 mb-4 flex flex-col sm:flex-row items-center justify-center gap-2">
                    <div>
                        Autenticado como: <span id="userEmailDisplay" class="font-medium"></span>
                    </div>
                    <button id="logoutButton" class="px-3 py-1 text-xs font-semibold rounded-full bg-gray-700 hover:bg-gray-600 text-gray-100 transition-colors duration-200">
                        Sair
                    </button>
                </div>
                <!-- Filtros e Busca do Feed -->
                <div id="feedFilters" class="mb-4 flex flex-col sm:flex-row items-stretch sm:items-center justify-between gap-3">
                    <input id="feedSearchInput" type="text" placeholder="Buscar no feed (título, descrição, tema)" class="w-full sm:w-1/2 px-4 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200" />
                    <div class="flex gap-2 w-full sm:w-auto">
                        <select id="channelFilter" class="flex-1 sm:flex-none px-3 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                            <option value="all">Todos os canais</option>
                        </select>
                        <select id="watchedFilter" class="flex-1 sm:flex-none px-3 py-2 bg-gray-700 text-gray-200 border border-gray-600 rounded-full focus:outline-none focus:ring-2 focus:ring-blue-500 transition-colors duration-200">
                            <option value="all">Todos</option>
                            <option value="new">Novos</option>
                            <option value="watched">Assistidos</option>
                        </select>
                    </div>
                </div>
                <!-- Player embutido (estilo YouTube) -->
                <div id="inlinePlayer" class="hidden sticky top-0 z-20 bg-gray-900/95 backdrop-blur border-b border-gray-800 py-3">
                    <div class="mx-auto w-[94vw] sm:w-[88vw] md:w-[80vw] lg:w-[72vw] xl:w-[64vw] max-w-[720px]">
                        <div class="relative">
                            <button id="inlineCloseButton" class="absolute -top-3 -right-3 w-8 h-8 rounded-full bg-gray-800 hover:bg-gray-700 text-gray-100 flex items-center justify-center shadow">
                                &times;
                            </button>
                            <div class="mb-2 flex items-center gap-2">
                                <button id="bgPlayButton" class="px-3 py-1.5 text-xs font-semibold rounded-full bg-indigo-600 hover:bg-indigo-500 text-white transition-colors">Segundo plano</button>
                            </div>
                            <div id="videoPlayerContainer" class="w-full aspect-video bg-black rounded-lg overflow-hidden shadow"></div>
                        </div>
                    </div>
                </div>
                <div id="curatedFeedContainer" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-6">
                    <!-- User's curated videos will be injected here by JavaScript -->
                </div>
            </section>
        </div>
    </div>

    <!-- JavaScript for functionality -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword, onAuthStateChanged, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getDatabase, ref, onValue, set } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-database.js";

        // Variáveis para armazenar o estado global
        let curatedFeed = [];
        let currentSearchResults = [];
        let userId = null;
        let appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        let player;
        let isDragging = false;
        let appSettings = {
            autoplayEnabled: true,
            autoplayMode: 'feed', // 'feed' | 'youtube'
            ytSync: false
        };
        
        // A sua chave da API do YouTube
        const YOUTUBE_API_KEY = "AIzaSyAmNMrkBFKqaUV-aOa1XBtJ5sEKBjDJwWA";

        // Esta função é chamada automaticamente quando a API do YouTube está pronta
        window.onYouTubeIframeAPIReady = () => {
            // A API está pronta, mas o player só será criado quando o usuário clicar em um vídeo.
        };

        // Função para lidar com o fim de um vídeo
        async function onPlayerStateChange(event) {
            // Verifica se o vídeo terminou
            if (event.data === YT.PlayerState.ENDED) {
                const currentVideoId = event.target.getVideoData().video_id;

                // Autoplay desativado
                if (!appSettings.autoplayEnabled) {
                    closeInlinePlayer?.();
                    return;
                }

                // Modo 'youtube' (sugestões do YouTube)
                if (appSettings.autoplayMode === 'youtube') {
                    try {
                        const params = new URLSearchParams({
                            part: 'snippet',
                            type: 'video',
                            key: YOUTUBE_API_KEY,
                            maxResults: '1',
                            relatedToVideoId: currentVideoId
                        });
                        const url = `https://www.googleapis.com/youtube/v3/search?${params.toString()}`;
                        const res = await fetch(url);
                        const data = await res.json();
                        const nextId = data?.items?.[0]?.id?.videoId;
                        if (nextId) {
                            playVideo(nextId);
                            return;
                        }
                    } catch (e) {
                        console.warn('Falha ao buscar sugestão do YouTube, caindo para feed:', e);
                    }
                    // fallback para feed
                }

                // Modo 'feed' (ou fallback): próximo do feed
                const currentIndex = curatedFeed.findIndex(v => v.id === currentVideoId);
                const nextIndex = currentIndex + 1;
                if (nextIndex < curatedFeed.length) {
                    const nextVideoId = curatedFeed[nextIndex].id;
                    playVideo(nextVideoId);
                } else {
                    closeInlinePlayer?.();
                }
            }
        }
        
        document.addEventListener('DOMContentLoaded', async () => {
            // --- DOM Elements ---
            const authScreen = document.getElementById('authScreen');
            const mainApp = document.getElementById('mainApp');
            const emailInput = document.getElementById('emailInput');
            const passwordInput = document.getElementById('passwordInput');
            const loginButton = document.getElementById('loginButton');
            const signupButton = document.getElementById('signupButton');
            const userEmailDisplay = document.getElementById('userEmailDisplay');

            const searchInput = document.getElementById('searchInput');
            const searchButton = document.getElementById('searchButton');
            const searchResultsContainer = document.getElementById('searchResultsContainer');
            const searchResultsGrid = document.getElementById('searchResultsGrid');
            const exitSearchButton = document.getElementById('exitSearchButton');
            const feedSection = document.getElementById('feedSection');
            const orderSelect = document.getElementById('orderSelect');
            const uploadDateSelect = document.getElementById('uploadDateSelect');
            const durationSelect = document.getElementById('durationSelect');
            const curatedFeedContainer = document.getElementById('curatedFeedContainer');
            const appModal = document.getElementById('appModal');
            const modalTitle = document.getElementById('modalTitle');
            const modalContent = document.getElementById('modalContent');
            const suggestTopicsButton = document.getElementById('suggestTopicsButton');
            const videoModal = document.getElementById('videoModal');
            const inlinePlayer = document.getElementById('inlinePlayer');
            const inlineCloseButton = document.getElementById('inlineCloseButton');
            const videoPlayerContainer = document.getElementById('videoPlayerContainer');
            const logoutButton = document.getElementById('logoutButton');
            const feedSearchInput = document.getElementById('feedSearchInput');
            const channelFilter = document.getElementById('channelFilter');
            const watchedFilter = document.getElementById('watchedFilter');
            const userMenuButton = document.getElementById('userMenuButton');
            const userMenu = document.getElementById('userMenu');
            const goToFeedMenuItem = document.getElementById('goToFeedMenuItem');
            const logoutMenuItem = document.getElementById('logoutMenuItem');
            const openSettings = document.getElementById('openSettings');
            const bgPlayButton = document.getElementById('bgPlayButton');

            // --- Firebase Setup ---
            const firebaseConfig = {
                apiKey: "AIzaSyAMiRmCeV0_S4-rl_Gh1K6SRo2Z1k1jQI0",
                authDomain: "nexomedicina-vr.firebaseapp.com",
                databaseURL: "https://nexomedicina-vr-default-rtdb.firebaseio.com",
                projectId: "nexomedicina-vr",
                storageBucket: "nexomedicina-vr.firebasestorage.app",
                messagingSenderId: "680752127319",
                appId: "1:680752127319:web:19e2a2027ea04d2e3d3212",
                measurementId: "G-EJLDRX2TKK"
            };

            const app = initializeApp(firebaseConfig);
            const db = getDatabase(app);
            const auth = getAuth(app);

            // --- Authentication Logic ---
            loginButton.addEventListener('click', async () => {
                const email = emailInput.value;
                const password = passwordInput.value;
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    showModal("Erro de Login", `Falha ao entrar: ${error.message}`);
                }
            });

            signupButton.addEventListener('click', async () => {
                const email = emailInput.value;
                const password = passwordInput.value;
                try {
                    await createUserWithEmailAndPassword(auth, email, password);
                    showModal("Sucesso", "Conta criada com sucesso! Você já está logado.");
                } catch (error) {
                    showModal("Erro ao Criar Conta", `Falha ao criar conta: ${error.message}`);
                }
            });

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    userEmailDisplay.textContent = user.email;
                    // Esconde a tela de autenticação e mostra o app principal
                    authScreen.classList.add('hidden');
                    mainApp.classList.remove('hidden');
                    listenToCuratedFeed();
                    listenToSettings();
                } else {
                    // Se o usuário não estiver logado, mostra a tela de autenticação
                    mainApp.classList.add('hidden');
                    authScreen.classList.remove('hidden');
                }
            });
            
            // Logout
            if (logoutButton) {
                logoutButton.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                    } catch (error) {
                        showModal("Erro ao Sair", `Falha ao sair da conta: ${error.message}`);
                    }
                });
            }

            // User menu (toggle + outside click)
            if (userMenuButton && userMenu) {
                userMenuButton.addEventListener('click', (e) => {
                    e.stopPropagation();
                    userMenu.classList.toggle('hidden');
                });
                document.addEventListener('click', (e) => {
                    if (!userMenu.classList.contains('hidden')) {
                        const within = userMenu.contains(e.target) || userMenuButton.contains(e.target);
                        if (!within) userMenu.classList.add('hidden');
                    }
                });
            }

            // User menu items
            if (logoutMenuItem) {
                logoutMenuItem.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                    } catch (error) {
                        showModal("Erro ao Sair", `Falha ao sair da conta: ${error.message}`);
                    } finally {
                        if (userMenu) userMenu.classList.add('hidden');
                    }
                });
            }
            if (openSettings) {
                openSettings.addEventListener('click', () => {
                    const html = `
                        <div class="space-y-4">
                            <div>
                                <label class="flex items-center gap-2">
                                    <input type="checkbox" id="stgAutoplay" class="accent-blue-500" ${appSettings.autoplayEnabled ? 'checked' : ''}>
                                    <span class="font-medium">Reprodução automática</span>
                                </label>
                                <p class="text-xs text-gray-400 mt-1">Ative para reproduzir o próximo vídeo automaticamente.</p>
                            </div>
                            <div id="stgAutoplayModeWrap" class="${appSettings.autoplayEnabled ? '' : 'opacity-50 pointer-events-none'}">
                                <label class="block text-sm font-medium mb-2">Próximo vídeo</label>
                                <label class="flex items-center gap-2 mb-1">
                                    <input type="radio" name="stgAutoplayMode" value="feed" ${appSettings.autoplayMode === 'feed' ? 'checked' : ''}>
                                    <span>Seguir ordem do seu Feed</span>
                                </label>
                                <label class="flex items-center gap-2">
                                    <input type="radio" name="stgAutoplayMode" value="youtube" ${appSettings.autoplayMode === 'youtube' ? 'checked' : ''}>
                                    <span>Sugestão do YouTube</span>
                                </label>
                            </div>
                            <hr class="border-gray-700">
                            <div>
                                <div class="flex items-center justify-between">
                                    <div>
                                        <div class="font-medium">Sincronizar com conta do YouTube</div>
                                        <p class="text-xs text-gray-400">Aproveite preferências e recomendações da sua conta.</p>
                                    </div>
                                    <button id="ytConnectBtn" class="px-3 py-1.5 text-sm rounded bg-gray-700 hover:bg-gray-600">Conectar</button>
                                </div>
                                <p class="text-xs text-gray-500 mt-2">Nota: integração completa requer login Google (em breve). Por ora, salvamos apenas sua preferência aqui.</p>
                            </div>
                            <div class="flex justify-end gap-2">
                                <button id="stgClose" class="px-3 py-1.5 text-sm rounded bg-gray-700 hover:bg-gray-600">Fechar</button>
                                <button id="stgSave" class="px-3 py-1.5 text-sm rounded bg-blue-600 hover:bg-blue-500 text-gray-900">Salvar</button>
                            </div>
                        </div>`;
                    showModal('Configurações', html);
                    if (userMenu) userMenu.classList.add('hidden');

                    const stgAutoplay = document.getElementById('stgAutoplay');
                    const stgAutoplayModeWrap = document.getElementById('stgAutoplayModeWrap');
                    const stgSave = document.getElementById('stgSave');
                    const stgClose = document.getElementById('stgClose');
                    const ytConnectBtn = document.getElementById('ytConnectBtn');
                    const modeInputs = Array.from(document.querySelectorAll('input[name="stgAutoplayMode"]'));

                    stgAutoplay?.addEventListener('change', () => {
                        if (stgAutoplay.checked) {
                            stgAutoplayModeWrap.classList.remove('opacity-50','pointer-events-none');
                        } else {
                            stgAutoplayModeWrap.classList.add('opacity-50','pointer-events-none');
                        }
                    });

                    ytConnectBtn?.addEventListener('click', (e) => {
                        e.preventDefault();
                        showModal('Conectar YouTube', '<p class="text-gray-300">Integração com a conta do YouTube virá em breve. Por enquanto, mantenha suas preferências salvas aqui.</p>');
                    });

                    stgClose?.addEventListener('click', () => closeModal());
                    stgSave?.addEventListener('click', async () => {
                        const enabled = !!stgAutoplay?.checked;
                        let mode = appSettings.autoplayMode;
                        if (enabled) {
                            const sel = modeInputs.find(i => i.checked);
                            if (sel) mode = sel.value;
                        }
                        await saveSettings({ autoplayEnabled: enabled, autoplayMode: mode });
                        closeModal();
                    });
                });
            }

            function exitSearch() {
                if (searchResultsContainer) searchResultsContainer.classList.add('hidden');
                if (feedSection) feedSection.classList.remove('hidden');
                if (searchResultsGrid) searchResultsGrid.innerHTML = '';
                if (orderSelect) orderSelect.value = 'relevance';
                if (uploadDateSelect) uploadDateSelect.value = 'any';
                if (durationSelect) durationSelect.value = 'any';
            }

            if (exitSearchButton) {
                exitSearchButton.addEventListener('click', () => exitSearch());
            }
            if (goToFeedMenuItem) {
                goToFeedMenuItem.addEventListener('click', () => {
                    exitSearch();
                    if (userMenu) userMenu.classList.add('hidden');
                });
            }

            // --- Background playback helpers ---
            function setupMediaSession(video) {
                if (!('mediaSession' in navigator) || !video) return;
                try {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: video.title || 'Reprodução',
                        artist: video.channel || 'Canal',
                        album: 'Meu Feed',
                        artwork: video.thumbnail ? [
                            { src: video.thumbnail, sizes: '512x288', type: 'image/jpeg' }
                        ] : []
                    });

                    navigator.mediaSession.setActionHandler('play', () => player?.playVideo?.());
                    navigator.mediaSession.setActionHandler('pause', () => player?.pauseVideo?.());
                    navigator.mediaSession.setActionHandler('previoustrack', () => {
                        const currentId = player?.getVideoData?.().video_id;
                        const i = curatedFeed.findIndex(v => v.id === currentId);
                        if (i > 0) playVideo(curatedFeed[i - 1].id);
                    });
                    navigator.mediaSession.setActionHandler('nexttrack', () => {
                        const currentId = player?.getVideoData?.().video_id;
                        const i = curatedFeed.findIndex(v => v.id === currentId);
                        if (i !== -1 && i + 1 < curatedFeed.length) playVideo(curatedFeed[i + 1].id);
                    });
                } catch (_) {}
            }

            async function enterBackgroundPlayback() {
                if (!player) {
                    showModal('Segundo plano', 'Abra um vídeo do seu feed primeiro.');
                    return;
                }
                try {
                    const iframe = player.getIframe();
                    if (iframe) {
                        const allow = iframe.getAttribute('allow') || '';
                        const merged = Array.from(new Set((allow + '; autoplay; encrypted-media; picture-in-picture; fullscreen').split(';').map(s => s.trim()).filter(Boolean))).join('; ');
                        iframe.setAttribute('allow', merged);
                        iframe.setAttribute('allowfullscreen', 'true');
                        iframe.setAttribute('playsinline', '1');
                    }
                    // Tentativa programática de PiP (pode não estar disponível)
                    if (document.pictureInPictureEnabled && iframe && typeof iframe.requestPictureInPicture === 'function') {
                        await iframe.requestPictureInPicture();
                        return;
                    }
                } catch (_) { /* silent */ }

                // Instruções de fallback
                const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
                const isAndroid = /Android/.test(navigator.userAgent);
                let tips = '';
                if (isIOS) {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Toque no vídeo em tela cheia e depois no botão Picture‑in‑Picture.</li><li>Saia do Safari: o áudio continua no fundo.</li></ul>';
                } else if (isAndroid) {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Toque no ícone Picture‑in‑Picture no player (ou use o menu do vídeo).</li><li>Pressione Home: o PiP mantém o áudio.</li></ul>';
                } else {
                    tips = '<ul class="list-disc list-inside space-y-1"><li>Clique com o botão direito no vídeo (duas vezes, se necessário) e escolha “Picture in Picture”.</li><li>Ou use o botão PiP na barra do player.</li></ul>';
                }
                showModal('Reprodução em segundo plano', `<p class="mb-2">Para continuar ouvindo com a tela minimizada, use Picture‑in‑Picture:</p>${tips}`);
            }

            if (bgPlayButton) {
                bgPlayButton.addEventListener('click', () => enterBackgroundPlayback());
            }

            function closeInlinePlayer() {
                if (player) {
                    try { player.destroy(); } catch (_) {}
                    player = null;
                }
                if (videoPlayerContainer) videoPlayerContainer.innerHTML = '';
                inlinePlayer?.classList.add('hidden');
            }
            inlineCloseButton?.addEventListener('click', closeInlinePlayer);

            // --- Realtime Database Functions ---
            const curatedFeedRef = () => ref(db, `/artifacts/${appId}/users/${userId}/curated_feed/feed_doc`);
            const settingsRef = () => ref(db, `/artifacts/${appId}/users/${userId}/settings`);

            const listenToCuratedFeed = () => {
                if (!userId) {
                    console.error("Usuário não autenticado. Não é possível ouvir o feed.");
                    return;
                }
                onValue(curatedFeedRef(), (snapshot) => {
                    const data = snapshot.val();
                    curatedFeed = data?.videos ?? [];
                    renderCuratedFeed();
                }, (error) => {
                    console.error("Erro ao ouvir o feed:", error);
                    showModal("Erro de Banco de Dados", "Não foi possível carregar o seu feed. Por favor, tente novamente.");
                });
            };

            const listenToSettings = () => {
                if (!userId) return;
                onValue(settingsRef(), (snapshot) => {
                    const data = snapshot.val();
                    if (data) {
                        appSettings = {
                            autoplayEnabled: data.autoplayEnabled ?? appSettings.autoplayEnabled,
                            autoplayMode: data.autoplayMode ?? appSettings.autoplayMode,
                            ytSync: data.ytSync ?? appSettings.ytSync
                        };
                    }
                });
            };

            const saveSettings = async (newSettings) => {
                if (!userId) return;
                appSettings = { ...appSettings, ...newSettings };
                try {
                    await set(settingsRef(), appSettings);
                } catch (e) {
                    console.error('Erro ao salvar configurações', e);
                    showModal('Erro', 'Não foi possível salvar as configurações. Tente novamente.');
                }
            };

            const saveCuratedFeed = async () => {
                if (!userId) {
                    console.error("Não é possível salvar o feed: usuário não autenticado.");
                    return;
                }
                try {
                    await set(curatedFeedRef(), { videos: curatedFeed });
                } catch (e) {
                    console.error("Erro ao salvar o feed:", e);
                    showModal("Erro ao Salvar", "Não foi possível salvar seu feed. Tente novamente.");
                }
            };

            // --- Utility Functions ---
            function showModal(title, content) {
                modalTitle.textContent = title;
                modalContent.innerHTML = content;
                appModal.style.display = 'flex';
            }

            window.closeModal = () => {
                appModal.style.display = 'none';
            };

            window.closeVideoModal = () => {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                }
                if (player) {
                    player.destroy();
                    player = null;
                }
                videoPlayerContainer.innerHTML = '';
                videoModal.classList.remove('flex');
                videoModal.classList.add('hidden');
            };

            function createVideoCard(video, isSearchResult = true) {
                const card = document.createElement('div');
                card.className = 'bg-gray-800 rounded-lg shadow-lg overflow-hidden transition-transform duration-200 hover:scale-105 hover:z-10 cursor-pointer';

                let buttonHtml = '';
                if (isSearchResult) {
                    buttonHtml = `
                        <button onclick="event.stopPropagation(); addToFeed('${video.id}')"
                                class="w-full mt-2 px-4 py-2 text-sm font-semibold text-gray-900 bg-blue-500 hover:bg-blue-400 rounded-full transition-colors duration-200">
                            Adicionar ao Feed
                        </button>
                        <button onclick="event.stopPropagation(); summarizeVideo('${video.id}')"
                                class="w-full mt-2 px-4 py-2 text-sm font-semibold rounded-full bg-purple-600 hover:bg-purple-500 transition-colors duration-200">
                            ✨ Resumir Vídeo
                        </button>
                    `;
                } else {
                    buttonHtml = '';
                }

                const durationBadge = video.duration ? `<span class="absolute bottom-2 right-2 text-xs bg-black/80 text-white px-2 py-0.5 rounded">${video.duration}</span>` : '';
                const liveBadge = video.isLive ? `<span class="absolute top-2 left-2 text-xs bg-red-600 text-white px-2 py-0.5 rounded">AO VIVO</span>` : '';
                const publishedInfo = video.publishedTime ? `<span class="text-xs text-gray-500">• ${video.publishedTime}</span>` : '';

                card.innerHTML = `
                    <div class="relative w-full aspect-video">
                        <img src="${video.thumbnail}" alt="Thumbnail do vídeo" class="w-full h-full object-cover">
                        ${durationBadge}
                        ${liveBadge}
                    </div>
                    <div class="p-4">
                        <h3 class="text-lg font-semibold line-clamp-2">${video.title}</h3>
                        <p class="text-sm text-gray-400 mt-1">${video.channel}</p>
                        <p class="text-xs text-gray-500">${video.views} ${publishedInfo}</p>
                        ${buttonHtml}
                    </div>
                `;

                if (!isSearchResult) {
                    // Arrastar para reordenar
                    card.setAttribute('draggable', 'true');
                    card.dataset.videoId = video.id;
                    card.addEventListener('dragstart', (e) => {
                        isDragging = true;
                        e.dataTransfer.setData('text/plain', video.id);
                        e.dataTransfer.effectAllowed = 'move';
                        card.classList.add('opacity-50');
                    });
                    card.addEventListener('dragend', () => {
                        isDragging = false;
                        card.classList.remove('opacity-50');
                    });
                    card.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        e.dataTransfer.dropEffect = 'move';
                        card.classList.add('ring-2', 'ring-blue-500');
                    });
                    card.addEventListener('dragleave', () => {
                        card.classList.remove('ring-2', 'ring-blue-500');
                    });
                    card.addEventListener('drop', (e) => {
                        e.preventDefault();
                        card.classList.remove('ring-2', 'ring-blue-500');
                        const draggedId = e.dataTransfer.getData('text/plain');
                        if (!draggedId || draggedId === video.id) return;
                        const fromIndex = curatedFeed.findIndex(v => v.id === draggedId);
                        const toIndex = curatedFeed.findIndex(v => v.id === video.id);
                        if (fromIndex === -1 || toIndex === -1) return;
                        const [moved] = curatedFeed.splice(fromIndex, 1);
                        curatedFeed.splice(toIndex, 0, moved);
                        saveCuratedFeed();
                        renderCuratedFeed();
                    });

                    // Clique para reproduzir (ignora se estiver arrastando)
                    card.addEventListener('click', () => {
                        if (isDragging) return;
                        playVideo(video.id);
                    });
                }
                
                return card;
            }

            function renderCuratedFeed() {
                curatedFeedContainer.innerHTML = '';
                rebuildChannelOptions();
                // Filtros
                const q = (feedSearchInput?.value || '').toLowerCase().trim();
                const selectedChannel = channelFilter?.value || 'all';
                const watchedMode = watchedFilter?.value || 'all';
                const filtered = curatedFeed.filter(v => {
                    const matchesQuery = !q || [v.title, v.description, v.channel].some(t => (t || '').toLowerCase().includes(q));
                    const matchesChannel = selectedChannel === 'all' || v.channel === selectedChannel;
                    const watched = !!v.watched;
                    const matchesWatched = watchedMode === 'all' || (watchedMode === 'new' ? !watched : watched);
                    return matchesQuery && matchesChannel && matchesWatched;
                });
                if (curatedFeed.length === 0) {
                    curatedFeedContainer.innerHTML = `
                        <p class="text-center text-gray-500 col-span-full mt-10">
                            Seu feed está vazio. Use a barra de pesquisa acima para encontrar vídeos e adicioná-los.
                        </p>
                    `;
                    suggestTopicsButton.classList.add('hidden');
                } else {
                    suggestTopicsButton.classList.remove('hidden');
                    if (filtered.length === 0) {
                        curatedFeedContainer.innerHTML = `
                            <p class="text-center text-gray-500 col-span-full mt-10">
                                Nenhum v��deo corresponde aos filtros/busca do feed.
                            </p>
                        `;
                    } else {
                        filtered.forEach(video => {
                            const card = createVideoCard(video, false);
                            curatedFeedContainer.appendChild(card);
                        });
                    }
                }
            }

            function rebuildChannelOptions() {
                if (!channelFilter) return;
                const current = channelFilter.value;
                const unique = Array.from(new Set(curatedFeed.map(v => v.channel).filter(Boolean))).sort((a, b) => a.localeCompare(b));
                channelFilter.innerHTML = '<option value="all">Todos os canais</option>' + unique.map(c => `<option value="${c.replace(/"/g, '&quot;')}">${c}</option>`).join('');
                if (unique.includes(current)) {
                    channelFilter.value = current;
                } else {
                    channelFilter.value = 'all';
                }
            }

            // --- Main Application Logic ---
            function formatViewCount(n) {
                if (!n) return '';
                const num = Number(n);
                if (num < 1000) return `${num} visualizações`;
                const units = ["mil", "mi", "bi", "tri"];
                let u = -1, v = num;
                while (v >= 1000 && u < units.length - 1) { v /= 1000; u++; }
                return `${v.toFixed(v < 10 ? 1 : 0)} ${units[u]} visualizações`;
            }

            function parseISODuration(iso) {
                if (!iso) return '';
                const m = iso.match(/PT(?:(\d+)H)?(?:(\d+)M)?(?:(\d+)S)?/);
                if (!m) return '';
                const h = parseInt(m[1]||'0',10), mi = parseInt(m[2]||'0',10), s = parseInt(m[3]||'0',10);
                const parts = [];
                if (h) parts.push(String(h));
                parts.push(String(h ? mi.toString().padStart(2,'0') : mi));
                parts.push(String(s).padStart(2,'0'));
                return parts.join(':');
            }

            function timeAgo(iso) {
                if (!iso) return '';
                const then = new Date(iso).getTime();
                const now = Date.now();
                const diff = Math.max(0, now - then);
                const s = Math.floor(diff/1000), m = Math.floor(s/60), h = Math.floor(m/60), d = Math.floor(h/24), w = Math.floor(d/7), mo = Math.floor(d/30), y = Math.floor(d/365);
                if (y>0) return `há ${y} ano${y>1?'s':''}`;
                if (mo>0) return `há ${mo} mês${mo>1?'es':''}`;
                if (w>0) return `há ${w} semana${w>1?'s':''}`;
                if (d>0) return `há ${d} dia${d>1?'s':''}`;
                if (h>0) return `há ${h} hora${h>1?'s':''}`;
                if (m>0) return `há ${m} minuto${m>1?'s':''}`;
                return `agora`;
            }

            function computePublishedAfter(option) {
                if (!option || option === 'any') return null;
                const now = new Date();
                const dt = new Date(now);
                switch(option){
                    case 'hour': dt.setHours(now.getHours()-1); break;
                    case 'day': dt.setDate(now.getDate()-1); break;
                    case 'week': dt.setDate(now.getDate()-7); break;
                    case 'month': dt.setMonth(now.getMonth()-1); break;
                    case 'year': dt.setFullYear(now.getFullYear()-1); break;
                }
                return dt.toISOString();
            }

            window.searchVideos = async () => {
                const query = searchInput.value.trim();
                if (!query) return;

                searchResultsGrid.innerHTML = `
                    <p class="col-span-full text-center text-gray-400">Buscando vídeos no YouTube...</p>
                    <div class="col-span-full flex justify-center mt-4">
                        <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-blue-500"></div>
                    </div>
                `;
                searchResultsContainer.classList.remove('hidden');
                if (feedSection) feedSection.classList.add('hidden');

                try {
                    const order = (orderSelect?.value)||'relevance';
                    const duration = (durationSelect?.value)||'any';
                    const uploadDate = (uploadDateSelect?.value)||'any';
                    const publishedAfter = computePublishedAfter(uploadDate);

                    const params = new URLSearchParams({
                        part: 'snippet',
                        q: query,
                        type: 'video',
                        key: YOUTUBE_API_KEY,
                        maxResults: '24',
                        order,
                        regionCode: 'BR',
                        relevanceLanguage: 'pt-BR',
                        safeSearch: 'strict'
                    });
                    if (duration !== 'any') params.set('videoDuration', duration);
                    if (publishedAfter) params.set('publishedAfter', publishedAfter);

                    const searchUrl = `https://www.googleapis.com/youtube/v3/search?${params.toString()}`;
                    const response = await fetch(searchUrl);
                    const data = await response.json();

                    if (data.items && data.items.length > 0) {
                        const ids = data.items.map(it => it.id.videoId).filter(Boolean);
                        let videos = [];
                        try {
                            const infoParams = new URLSearchParams({
                                part: 'snippet,contentDetails,statistics',
                                id: ids.join(','),
                                key: YOUTUBE_API_KEY
                            });
                            const infoUrl = `https://www.googleapis.com/youtube/v3/videos?${infoParams.toString()}`;
                            const infoRes = await fetch(infoUrl);
                            const info = await infoRes.json();
                            const byId = new Map(info.items.map(v => [v.id, v]));
                            videos = data.items.map(item => {
                                const v = byId.get(item.id.videoId);
                                const snippet = v?.snippet || item.snippet;
                                const stats = v?.statistics;
                                const details = v?.contentDetails;
                                const isLive = (snippet?.liveBroadcastContent === 'live');
                                return {
                                    id: item.id.videoId,
                                    title: snippet?.title || item.snippet.title,
                                    channel: snippet?.channelTitle || item.snippet.channelTitle,
                                    thumbnail: (snippet?.thumbnails?.maxres?.url || snippet?.thumbnails?.high?.url || item.snippet.thumbnails.high.url),
                                    views: formatViewCount(stats?.viewCount),
                                    duration: isLive ? null : parseISODuration(details?.duration),
                                    publishedTime: timeAgo(snippet?.publishedAt),
                                    description: snippet?.description,
                                    isLive
                                };
                            });
                        } catch (e) {
                            // Fallback se a chamada /videos falhar
                            videos = data.items.map(item => ({
                                id: item.id.videoId,
                                title: item.snippet.title,
                                channel: item.snippet.channelTitle,
                                thumbnail: item.snippet.thumbnails.high.url,
                                views: '',
                                duration: null,
                                publishedTime: timeAgo(item.snippet.publishedAt),
                                description: item.snippet.description,
                                isLive: item.snippet.liveBroadcastContent === 'live'
                            }));
                        }

                        currentSearchResults = videos;
                        searchResultsGrid.innerHTML = '';
                        videos.forEach(video => {
                            const card = createVideoCard(video, true);
                            searchResultsGrid.appendChild(card);
                        });
                    } else {
                        searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-gray-500">Nenhum vídeo encontrado para "${query}".</p>`;
                        currentSearchResults = [];
                    }
                } catch (error) {
                    console.error("Erro ao buscar vídeos do YouTube:", error);
                    searchResultsGrid.innerHTML = `<p class="col-span-full text-center text-red-500">Ocorreu um erro ao conectar com a API do YouTube. Verifique sua chave de API ou sua conexão com a internet.</p>`;
                    currentSearchResults = [];
                }
            };

            window.addToFeed = (videoId) => {
                const videoToAdd = currentSearchResults.find(video => video.id === videoId);
                if (videoToAdd) {
                    const isDuplicate = curatedFeed.some(video => video.id === videoToAdd.id);
                    if (!isDuplicate) {
                        curatedFeed.unshift(videoToAdd);
                        saveCuratedFeed();
                    } else {
                        showModal("Aviso", "Este vídeo já está no seu feed!");
                    }
                } else {
                    showModal("Erro", "Vídeo não encontrado nos resultados da busca.");
                }
            };

            window.removeFromFeed = (videoId) => {
                const index = curatedFeed.findIndex(video => video.id === videoId);
                if (index !== -1) {
                    curatedFeed.splice(index, 1);
                    saveCuratedFeed();
                }
            };

            window.playVideo = (videoId) => {
                // Marca como assistido ao abrir o vídeo
                const idx = curatedFeed.findIndex(v => v.id === videoId);
                if (idx !== -1 && !curatedFeed[idx].watched) {
                    curatedFeed[idx].watched = true;
                    saveCuratedFeed();
                    renderCuratedFeed();
                }
                // Atualiza Media Session
                try {
                    const meta = curatedFeed.find(v => v.id === videoId) || currentSearchResults.find(v => v.id === videoId);
                    setupMediaSession(meta);
                } catch (_) {}
                // Mostrar player embutido
                inlinePlayer?.classList.remove('hidden');
                if (!player) {
                    // Cria o player do YouTube pela primeira vez (embutido)
                    player = new YT.Player('videoPlayerContainer', {
                        height: '100%',
                        width: '100%',
                        videoId: videoId,
                        events: {
                            'onStateChange': onPlayerStateChange,
                            'onReady': e => {
                                const ifr = e.target.getIframe();
                                try {
                                    const allow = ifr.getAttribute('allow') || '';
                                    const merged = Array.from(new Set((allow + '; autoplay; encrypted-media; picture-in-picture; fullscreen').split(';').map(s => s.trim()).filter(Boolean))).join('; ');
                                    ifr.setAttribute('allow', merged);
                                    ifr.setAttribute('allowfullscreen', 'true');
                                    ifr.setAttribute('playsinline', '1');
                                } catch (_) {}
                            }
                        }
                    });
                } else {
                    // Se o player já existe, apenas carrega o novo vídeo
                    player.loadVideoById(videoId);
                }
            };
            
            // --- Gemini API Integrations ---
            window.summarizeVideo = async (videoId) => {
                const video = currentSearchResults.find(v => v.id === videoId);
                if (!video) {
                    showModal("Erro", "Vídeo não encontrado nos resultados da busca.");
                    return;
                }

                showModal("Resumindo Vídeo...", '<div class="text-center"><p>Gerando resumo com a inteligência do Gemini...</p><div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mt-4"><div class="bg-blue-500 h-full w-full animate-pulse"></div></div></div>');

                try {
                    const prompt = `Gere um resumo curto e objetivo (no máximo 3 frases) para o seguinte vídeo. Considere o título, o canal e a descrição:
                    Título: ${video.title}
                    Canal: ${video.channel}
                    Descrição: ${video.description || 'Nenhuma descrição fornecida.'}`;

                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = { contents: chatHistory };
                    const apiKey = "" 
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error('Falha na resposta da API.');

                    const result = await response.json();
                    const summary = result?.candidates?.[0]?.content?.parts?.[0]?.text;

                    if (summary) {
                        showModal("Resumo do Vídeo", summary);
                    } else {
                        showModal("Erro", "Não foi possível gerar o resumo. Tente novamente mais tarde.");
                    }
                } catch (error) {
                    console.error("Erro ao gerar resumo:", error);
                    showModal("Erro", "Ocorreu um erro ao conectar com o serviço de IA. Por favor, tente novamente.");
                }
            };

            suggestTopicsButton.addEventListener('click', async () => {
                if (curatedFeed.length === 0) {
                    showModal("Aviso", "Adicione vídeos ao seu feed primeiro para receber sugestões de tópicos.");
                    return;
                }

                showModal("Gerando Sugestões...", '<div class="text-center"><p>Analisando seu feed e buscando sugestões...</p><div class="w-full bg-gray-700 h-2 rounded-full overflow-hidden mt-4"><div class="bg-yellow-500 h-full w-full animate-pulse"></div></div></div>');

                try {
                    const videoTitles = curatedFeed.map(v => v.title).join(', ');
                    const prompt = `Analise os seguintes títulos de vídeos de uma playlist e sugira 3 tópicos de vídeos relacionados para um feed. A resposta deve ser uma lista JSON de strings, sem formatação extra, como um array de strings.
                    Títulos da playlist: ${videoTitles}`;

                    const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                    const payload = {
                        contents: chatHistory,
                        generationConfig: {
                            responseMimeType: "application/json",
                            responseSchema: {
                                type: "ARRAY",
                                items: { "type": "STRING" }
                            }
                        }
                    };
                    const apiKey = ""
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
                    
                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!response.ok) throw new Error('Falha na resposta da API.');

                    const result = await response.json();
                    const suggestions = JSON.parse(result?.candidates?.[0]?.content?.parts?.[0]?.text || '[]');

                    if (suggestions.length > 0) {
                        const listHtml = `
                            <p>Com base nos vídeos do seu feed, aqui estão algumas sugestões:</p>
                            <ul class="list-disc list-inside mt-4 space-y-2">
                                ${suggestions.map(s => `<li>${s}</li>`).join('')}
                            </ul>
                        `;
                        showModal("Tópicos Sugeridos", listHtml);
                    } else {
                        showModal("Erro", "Não foi possível gerar sugestões. Tente adicionar mais vídeos ao seu feed.");
                    }
                } catch (error) {
                    console.error("Erro ao gerar sugestões:", error);
                    showModal("Erro", "Ocorreu um erro ao gerar as sugestões. Por favor, tente novamente.");
                }
            });
            
            searchButton.addEventListener('click', searchVideos);
            searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    searchVideos();
                }
            });
            if (orderSelect) orderSelect.addEventListener('change', () => searchVideos());
            if (uploadDateSelect) uploadDateSelect.addEventListener('change', () => searchVideos());
            if (durationSelect) durationSelect.addEventListener('change', () => searchVideos());
            // Eventos de filtros/busca do feed
            if (feedSearchInput) feedSearchInput.addEventListener('input', renderCuratedFeed);
            if (channelFilter) channelFilter.addEventListener('change', renderCuratedFeed);
            if (watchedFilter) watchedFilter.addEventListener('change', renderCuratedFeed);
        });
    </script>
</body>
</html>
